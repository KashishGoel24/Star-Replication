Server design 

1. To keep track of mapping from key to value we still maintain a dictionary from str to str
2. Each key is mapped to a tuple of request id and the verison number and hence (str, Optional[int])
3. version state remains the same mapping a key to either dirty or clean state
4. right now there is self.next and self.prev but later we will change this
5. we will define a queue for every server where we put the changes in the requests we get and process them one by one
6. scratch space - this is going to be a dictionary having key of types (key, request id) = (str, str) mapping to the value of type [version number, version state]



Scratch space need:

- when there are different write requests that are unversioned / uncommitted, then there is chance of writing the writes in incorrect order
- to prevent this we need a scratch space
- even if we dont have strict linearizability it will work as long as we are consistent with the tail
- so the following requests will process their request in the following way :
- get : its changes will be directly written down in the main dictionaries
- set : its changes will be written down in the scratch space
- ack : this will pick up the element from the scratch space, remove it from there and put the changes in the main dictionaries 


version number:

initial idea: we need that the version number increases monotonically, we dont necessarily want that it be increased by 1
                so we assign the new version number as the current version number + number of requests in queue + number of requests in the buffer
                to optimise this a bit we can keep a direct count of the number of pending set requests too and just make it curr vn + no of pending set requests